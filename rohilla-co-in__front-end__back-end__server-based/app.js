
const express = require('express')
const app = express()
app.use(express.static('./static'))
app.use(express.urlencoded({ extended: false }))
app.use(express.json())

const helmet = require('helmet')
const cors = require('cors')
const xss = require('xss-clean')
const rateLimiter = require('express-rate-limit')
app.set('trust proxy', 1)
app.use(rateLimiter({
    windowMs: 15*60*1000, // 15 minutes
    max: 100,
}))
app.use(helmet())
app.use(cors({
    origin: 'http://localhost',
    optionsSuccessStatus: 200
}))
app.use(xss())


require('dotenv').config()
require('express-async-errors')
const jwt = require('jsonwebtoken')
const bcrpyt = require('bcryptjs')
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 80
const JWT_SECRET     = process.env.JWT_SECRET     || 'thirty-two-character-long-secret' // 32byte long string
const COOKIE_SECRET  = process.env.COOKIE_SECRET  || 'COOKIE_SECRET_CODE'
const CONNECTION_STRING = process.env.MONGODB_CONNECTION_STRING || 'mongodb://localhost/rohilla_co_in'

app.use(cookieParser(COOKIE_SECRET))

const mongoose = require('mongoose')
mongoose.connect(CONNECTION_STRING)
    .then(() => {
        console.log('CONNECTED to database...')
        app.listen(PORT, () => {
            console.log(`Server listening on port ${PORT}...`);
        })
    })
    .catch((err) => console.log(`FAILED to connect to database...\nerror : ${err}`))

const UserSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, `Name can't be empty`],
        minlength: 2,
        maxlength: 50,
    }, 
    email: {
        type: String,
        required: [true, `Email can't be empty`],
        minlength: 6,
        maxlength: 50,
        match: [/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, `Email format is invalid`],
        unique: true
    },
    password: {
        type: String,
        required: [true, `Password can't be empty`],
        minlength: 8,
    },
}, {timestamps: true})

UserSchema.methods.generateToken = function() {
    return jwt.sign({userID: this._id, username: this.name}, JWT_SECRET, {expiresIn: '30d'})
}

const ContactSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, `Name can't be empty`],
        minlength: 2,
        maxlength: 50,
    }, 
    email: {
        type: String,
        required: [true, `Email can't be empty`],
        minlength: 6,
        maxlength: 50,
        match: [/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, `Email format is invalid`],
    },
    subject: {
        type: String,
        required: [true, `Subject can't be empty`],
    },
    message: {
        type: String,
        required: [true, `Message can't be empty`],
    },
}, {timestamps: true})


const User = mongoose.model('User', UserSchema)
const Contact = mongoose.model('Contact', ContactSchema)

const categories = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark']

app.post('/signup', async (req, res) => {
    
    const name     = req.body.name.trim()
    const email    = req.body.email.trim()
    const password = req.body.password.trim()

    const salt = await bcrpyt.genSalt(10); // salt is randomly generated bytes
    const hashedPassword = await bcrpyt.hash(password, salt);

    try {
        if(await User.findOne({email}))
            return res.json({message: `${email} is already registered`, category: 'danger', status: 'error'})

        const user = await User.create({name, email, password: hashedPassword})
        const token = user.generateToken()
        const oneDay = 1000 * 60 * 60 * 24;
        res.cookie('token', token, {
            httpOnly: true,
            expires: new Date(Date.now() + 30*oneDay),
            // secure: true,
            signed: true,
            // path: '/',
        });
        const username = user.name.includes(' ') ? user.name.split(' ')[0] : user.name
        res.cookie('username', username, {
            expires: new Date(Date.now() + 30*oneDay),
            // secure: true,
            signed: false,
            path: '/',
        });
    

        res.json({message: 'Account Created!', category: 'success', status: 'success'})
    } catch (err) {
        res.json({message: 'Something went wrong', category: 'danger', status: 'error'})
    }
})

app.post('/login', async (req, res) => {

    const email    = req.body.email.trim()
    const password = req.body.password.trim()
    
    if(!email || !password) {
        return res.json({status: 'error', message:'Email and/or password is empty', category: 'danger'})
    }

    const user = await User.findOne({email})
    if(!user) {
        return res.json({status: 'error', message:`${email} is not registered`, category: 'danger'})
    }
    if(! await bcrpyt.compare(password, user.password)) {
        return res.json({status: 'error', message:'Password is incorrect', category: 'danger'})
    }

    const token = user.generateToken() 
    const oneDay = 1000 * 60 * 60 * 24;
    res.cookie('token', token, {
        httpOnly: true,
        expires: new Date(Date.now() + 30*oneDay),
        // secure: true,
        signed: true,
        path: '/',
    });

    const username = user.name.includes(' ') ? user.name.split(' ')[0] : user.name
    res.cookie('username', username, {
        expires: new Date(Date.now() + 30*oneDay),
        // secure: true,
        signed: false,
        path: '/',
    });


    return res.json({status: 'success', message:'Login Successful!', category: 'success'})
})

app.post('/contact', async (req, res) => {
    
    const name    = req.body.name.trim()
    const email   = req.body.email.trim()
    const subject = req.body.subject.trim()
    const message = req.body.message.trim()

    if(!name || ! email || !subject || !message) {
        return res.json({message: 'Some fields are empty', category: 'danger', status: 'error'})
    }

    try {
        await Contact.create({name, email, subject, message})
        res.json({message: 'Thank You for your response!', category: 'success', status: 'success'})
    } catch (err) {
        res.json({message: 'Something went wrong', category: 'danger', status: 'error'})
    }
})


app.get('/logout', async (req, res) => {
    res.clearCookie('token');
    res.clearCookie('username');
    res.redirect('/')
})

app.get('/api', (req, res) => {
    res.json({msg: 'Api Responded'})
})

app.get('*', (req, res) => {
    res.status(404).send(`<style>body {
        background-color: rgb(38,38,38); color: lightsteelblue; height: 98vh;
        display: flex; flex-direction: column; 
        justify-content: center; align-items: center;
    }</style><pre style="font-size: 3.5rem !important;">Page Not Found</pre>`)
})

const errorHandler = (err, req, res, next) => {
    res.json({status: 'error', message: 'Something went wrong', category: 'danger'})
}
app.use(errorHandler)

// app.listen(PORT, () => {
//     console.log(`Server listening on port ${PORT}...`)
// })
